"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var fuse_js_1 = __importDefault(require("fuse.js"));
var lib_1 = __importDefault(require("./lib"));
var createQuestions = function (config) {
    var choices = lib_1.default.selectEmojiOptions(config);
    var fuzzy = new fuse_js_1.default(choices, {
        shouldSort: true,
        threshold: 0.4,
        location: 0,
        distance: 100,
        maxPatternLength: 32,
        minMatchCharLength: 1,
        keys: ['name', 'code']
    });
    var questions = [
        {
            type: 'autocomplete',
            name: 'type',
            message: config.questions.type,
            source: function (_, query) { return Promise.resolve(query ? fuzzy.search(query) : choices); }
        },
        {
            type: config.scopes.length ? 'list' : 'input',
            name: 'scope',
            message: config.questions.scope,
            choices: config.scopes.length && [{ name: '[none]', value: '' }].concat(config.scopes),
            when: !config.skipQuestions.includes('scope')
        },
        {
            type: 'maxlength-input',
            name: 'subject',
            message: config.questions.subject,
            maxLength: config.subjectMaxLength,
            filter: function (subject, answers) { return lib_1.default.formatTitle(__assign(__assign({}, answers), { subject: subject }), config); }
        },
        {
            type: 'input',
            name: 'body',
            message: config.questions.body,
            when: !config.skipQuestions.includes('body')
        },
        {
            type: 'input',
            name: 'breakingBody',
            message: config.questions.breakingBody,
            when: !config.skipQuestions.includes('breakingBody')
        },
        {
            type: 'input',
            name: 'issues',
            message: config.questions.issues,
            when: !config.skipQuestions.includes('issues')
        }
    ];
    return questions;
};
exports.default = {
    prompter: function (cz, commit) {
        cz.prompt.registerPrompt('autocomplete', require('inquirer-autocomplete-prompt'));
        cz.prompt.registerPrompt('maxlength-input', require('inquirer-maxlength-input-prompt'));
        lib_1.default.getConfig()
            .then(function (config) { return ({ config: config, questions: createQuestions(config) }); })
            .then(function (_a) {
            var config = _a.config, questions = _a.questions;
            return cz.prompt(questions)
                .then(function (answers) { return ({ config: config, answers: answers }); });
        })
            .then(function (_a) {
            var config = _a.config, answers = _a.answers;
            return lib_1.default.finalFormat(answers, config);
        })
            .then(commit);
    }
};
